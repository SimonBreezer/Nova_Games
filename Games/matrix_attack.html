<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Attack</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            border: 1px solid #0f0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const PLAYER_WIDTH = 20;
        const PLAYER_HEIGHT = 20;
        const CODE_WIDTH = 30;
        const CODE_HEIGHT = 20;
        const COLUMN_WIDTH = 40;
        const NUM_COLUMNS = Math.floor(CANVAS_WIDTH / COLUMN_WIDTH);

        // Game State
        let player = {
            x: CANVAS_WIDTH / 2 - PLAYER_WIDTH / 2,
            y: CANVAS_HEIGHT - PLAYER_HEIGHT - 10,
            speed: 5,
            lives: 3
        };
        let codeStreams = [];
        let abilities = {
            grindMode: { active: false, recharge: 0, maxRecharge: 300 },
            matrixImmunity: { active: false, recharge: 0, maxRecharge: 400 },
            timeControl: { active: false, recharge: 0, maxRecharge: 500 },
            codeCloak: { active: false, recharge: 0, maxRecharge: 350 },
            binaryBlast: { active: false, recharge: 0, maxRecharge: 450 },
            dataDash: { active: false, recharge: 0, maxRecharge: 300 }
        };
        let score = 0;
        let gameOver = false;
        let bossActive = false;
        let boss = null;
        let projectiles = [];
        let powerUp = null;

        // Input Handling
        let keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Code Stream Class
        class CodeStream {
            constructor(x, speed, binary) {
                this.x = x;
                this.y = -CODE_HEIGHT;
                this.speed = speed;
                this.binary = binary; // Random binary string
            }
            update() {
                this.y += this.speed * (abilities.timeControl.active ? 0.5 : 1);
            }
            draw() {
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x, this.y, CODE_WIDTH, CODE_HEIGHT);
                ctx.font = '12px Arial';
                ctx.fillStyle = '#000';
                ctx.fillText(this.binary, this.x + 2, this.y + 15);
            }
        }

        // Boss Class
        class Boss {
            constructor(name, health, attackPattern) {
                this.name = name;
                this.health = health;
                this.x = CANVAS_WIDTH / 2 - 50;
                this.y = 50;
                this.width = 100;
                this.height = 100;
                this.attackPattern = attackPattern;
                this.attackTimer = 0;
            }
            update() {
                this.attackTimer++;
                if (this.attackTimer > 60) {
                    this.attackPattern();
                    this.attackTimer = 0;
                }
            }
            draw() {
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#000';
                ctx.font = '20px Arial';
                ctx.fillText(this.name, this.x + 10, this.y + 50);
                ctx.fillText(`HP: ${this.health}`, this.x + 10, this.y + 70);
            }
        }

        // Power-Up Class
        class PowerUp {
            constructor() {
                this.x = Math.random() * (CANVAS_WIDTH - 20);
                this.y = CANVAS_HEIGHT / 2;
                this.width = 20;
                this.height = 20;
                this.collected = false;
            }
            draw() {
                ctx.fillStyle = '#ff0';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#000';
                ctx.font = '10px Arial';
                ctx.fillText('KB', this.x + 4, this.y + 15);
            }
        }

        // Projectile Class
        class Projectile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = -5;
            }
            update() {
                this.y += this.speed;
            }
            draw() {
                ctx.fillStyle = '#fff';
                ctx.font = '15px Arial';
                ctx.fillText('truth', this.x, this.y);
            }
        }

        // Generate Random Binary String
        function getRandomBinary() {
            let binary = '';
            for (let i = 0; i < 6; i++) {
                binary += Math.random() < 0.5 ? '0' : '1';
            }
            return binary;
        }

        // Spawn Code Streams with Safe Path
        function spawnCode() {
            if (!bossActive && Math.random() < 0.2) { // Increased spawn rate
                let safeColumn = Math.floor(player.x / COLUMN_WIDTH); // Ensure a safe path near player
                for (let i = 0; i < NUM_COLUMNS; i++) {
                    if (i !== safeColumn && i !== safeColumn + 1 && Math.random() < 0.8) { // Gaps for safe path
                        let x = i * COLUMN_WIDTH;
                        codeStreams.push(new CodeStream(x, 2 + score / 1000, getRandomBinary()));
                    }
                }
            }
        }

        // Spawn Boss
        function spawnBoss() {
            if (!bossActive) {
                if (score >= 1000 && !boss) {
                    boss = new Boss('Politician', 5, () => {
                        codeStreams.push(new CodeStream(boss.x + boss.width / 2, 3, getRandomBinary()));
                    });
                    powerUp = new PowerUp();
                    bossActive = true;
                } else if (score >= 3000 && !boss) {
                    boss = new Boss('Media Mogul', 6, () => {
                        codeStreams.push(new CodeStream(boss.x + boss.width / 4, 3, getRandomBinary()));
                        codeStreams.push(new CodeStream(boss.x + 3 * boss.width / 4, 3, getRandomBinary()));
                    });
                    powerUp = new PowerUp();
                    bossActive = true;
                } else if (score >= 6000 && !boss) {
                    boss = new Boss('Corporate Overlord', 7, () => {
                        for (let i = 0; i < 3; i++) {
                            codeStreams.push(new CodeStream(boss.x + i * 30, 3, getRandomBinary()));
                        }
                    });
                    powerUp = new PowerUp();
                    bossActive = true;
                } else if (score >= 10000 && !boss) {
                    boss = new Boss('AI Overmind', 8, () => {
                        codeStreams.push(new CodeStream(boss.x + Math.random() * boss.width, 4, getRandomBinary()));
                    });
                    powerUp = new PowerUp();
                    bossActive = true;
                }
            }
        }

        // Update Game
        function update() {
            if (gameOver) return;

            // Player Movement
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed * (abilities.dataDash.active ? 2 : 1);
            if (keys['ArrowRight'] && player.x < CANVAS_WIDTH - PLAYER_WIDTH) player.x += player.speed * (abilities.dataDash.active ? 2 : 1);
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed * (abilities.dataDash.active ? 2 : 1);
            if (keys['ArrowDown'] && player.y < CANVAS_HEIGHT - PLAYER_HEIGHT) player.y += player.speed * (abilities.dataDash.active ? 2 : 1);

            // Abilities
            if (keys['Digit1'] && abilities.grindMode.recharge >= abilities.grindMode.maxRecharge) {
                abilities.grindMode.active = true;
                abilities.grindMode.recharge = 0;
                setTimeout(() => abilities.grindMode.active = false, 2000);
            }
            if (keys['Digit2'] && abilities.matrixImmunity.recharge >= abilities.matrixImmunity.maxRecharge) {
                abilities.matrixImmunity.active = true;
                abilities.matrixImmunity.recharge = 0;
                setTimeout(() => abilities.matrixImmunity.active = false, 3000);
            }
            if (keys['Digit3'] && abilities.timeControl.recharge >= abilities.timeControl.maxRecharge) {
                abilities.timeControl.active = true;
                abilities.timeControl.recharge = 0;
                setTimeout(() => abilities.timeControl.active = false, 4000);
            }
            if (keys['Digit4'] && abilities.codeCloak.recharge >= abilities.codeCloak.maxRecharge) {
                abilities.codeCloak.active = true;
                abilities.codeCloak.recharge = 0;
                setTimeout(() => abilities.codeCloak.active = false, 5000);
            }
            if (keys['Digit5'] && abilities.binaryBlast.recharge >= abilities.binaryBlast.maxRecharge) {
                abilities.binaryBlast.active = true;
                abilities.binaryBlast.recharge = 0;
                setTimeout(() => abilities.binaryBlast.active = false, 1000);
            }
            if (keys['Digit6'] && abilities.dataDash.recharge >= abilities.dataDash.maxRecharge) {
                abilities.dataDash.active = true;
                abilities.dataDash.recharge = 0;
                setTimeout(() => abilities.dataDash.active = false, 2000);
            }
            if (keys['Space'] && powerUp && powerUp.collected) {
                projectiles.push(new Projectile(player.x + PLAYER_WIDTH / 2, player.y));
            }

            // Auto-Collect Power-Up
            if (powerUp && !powerUp.collected &&
                player.x < powerUp.x + powerUp.width && player.x + PLAYER_WIDTH > powerUp.x &&
                player.y < powerUp.y + powerUp.height && player.y + PLAYER_HEIGHT > powerUp.y) {
                powerUp.collected = true;
            }

            // Recharge Abilities
            for (let ability in abilities) {
                if (abilities[ability].recharge < abilities[ability].maxRecharge) {
                    abilities[ability].recharge++;
                }
            }

            // Update Code Streams
            spawnCode();
            codeStreams.forEach((code, index) => {
                code.update();
                if (abilities.grindMode.active && Math.abs(code.x - player.x) < 50) {
                    codeStreams.splice(index, 1);
                } else if (abilities.matrixImmunity.active && Math.abs(code.x - player.x) < 50 && Math.abs(code.y - player.y) < 50) {
                    codeStreams.splice(index, 1);
                } else if (abilities.binaryBlast.active && Math.abs(code.x - player.x) < 50 && code.y < player.y) {
                    codeStreams.splice(index, 1);
                } else if (code.y > CANVAS_HEIGHT) {
                    codeStreams.splice(index, 1);
                    score += 10;
                } else if (!abilities.codeCloak.active && code.x < player.x + PLAYER_WIDTH && code.x + CODE_WIDTH > player.x &&
                    code.y < player.y + PLAYER_HEIGHT && code.y + CODE_HEIGHT > player.y) {
                    codeStreams.splice(index, 1);
                    player.lives--;
                    if (player.lives <= 0) gameOver = true;
                }
            });

            // Update Boss
            spawnBoss();
            if (boss) {
                boss.update();
                if (powerUp && !powerUp.collected) powerUp.y += 1;
                projectiles.forEach((proj, index) => {
                    proj.update();
                    if (proj.x > boss.x && proj.x < boss.x + boss.width && proj.y > boss.y && proj.y < boss.y + boss.height) {
                        boss.health--;
                        projectiles.splice(index, 1);
                        if (boss.health <= 0) {
                            boss = null;
                            bossActive = false;
                            powerUp = null;
                            codeStreams = [];
                        }
                    } else if (proj.y < 0) {
                        projectiles.splice(index, 1);
                    }
                });
            }
        }

        // Draw Game
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw Player
            ctx.fillStyle = abilities.codeCloak.active ? 'rgba(0, 255, 0, 0.5)' : '#0f0';
            ctx.fillRect(player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT);
            if (abilities.matrixImmunity.active) {
                ctx.beginPath();
                ctx.arc(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, 50, 0, Math.PI * 2);
                ctx.strokeStyle = '#0f0';
                ctx.stroke();
            }

            // Draw Code Streams
            codeStreams.forEach(code => code.draw());

            // Draw Boss and Power-Up
            if (boss) boss.draw();
            if (powerUp && !powerUp.collected) powerUp.draw();
            projectiles.forEach(proj => proj.draw());

            // Draw HUD
            ctx.fillStyle = '#0f0';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.fillText(`Lives: ${player.lives}`, 10, 60);
            ctx.fillText('Abilities: 1:Grind 2:Immunity 3:Time 4:Cloak 5:Blast 6:Dash', 10, CANVAS_HEIGHT - 40);
            let abilityStatus = '';
            for (let ability in abilities) {
                abilityStatus += `${ability}: ${(abilities[ability].recharge / abilities[ability].maxRecharge * 100).toFixed(0)}% `;
            }
            ctx.fillText(abilityStatus, 10, CANVAS_HEIGHT - 10);

            if (gameOver) {
                ctx.fillStyle = '#f00';
                ctx.font = '40px Arial';
                ctx.fillText('GAME OVER', CANVAS_WIDTH / 2 - 100, CANVAS_HEIGHT / 2);
            }
        }

        // Game Loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
