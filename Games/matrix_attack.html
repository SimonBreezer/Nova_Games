<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Attack</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1400" height="600"></canvas>
    <script>
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state variables
        let score = 0;
        let lives = 50;
        let player = { x: 490, y: 570, width: 20, height: 20, speed: 5 };
        let codeCharacters = [];
        let columns = [];
        for (let i = 0; i < 50; i++) {
            columns.push(400 + i * 20 + 10); // Center of each 20px-wide column
        }
        let abilities = [
            { name: "Grind Mode", rechargeTime: 300, currentRecharge: 0 },
            { name: "Matrix Immunity", rechargeTime: 400, currentRecharge: 0 },
            { name: "Time Control", rechargeTime: 500, currentRecharge: 0 },
            { name: "Binary Blast", rechargeTime: 350, currentRecharge: 0 },
            { name: "Data Dash", rechargeTime: 250, currentRecharge: 0 }
        ];
        let keys = {};
        let matrixImmunityActive = false;
        let matrixImmunityTimer = 0;
        let timeControlActive = false;
        let timeControlTimer = 0;
        let binaryBlastActive = false;
        let binaryBlastTimer = 0;
        let dataDashActive = false;
        let dataDashTimer = 0;
        let boss = null;
        let powerUp = null;
        let canShoot = false;
        let projectiles = [];
        let frameCount = 0;

        // Keyboard event listeners
        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; });

        // Ability activation functions
        function activateGrindMode() {
            let clearLeft = player.x - 25;
            let clearRight = player.x + 25;
            codeCharacters = codeCharacters.filter((code) => code.x < clearLeft || code.x > clearRight);
        }

        function activateMatrixImmunity() {
            matrixImmunityActive = true;
            matrixImmunityTimer = 180; // 3 seconds at 60 fps
        }

        function activateTimeControl() {
            timeControlActive = true;
            timeControlTimer = 240; // 4 seconds
        }

        function activateBinaryBlast() {
            binaryBlastActive = true;
            binaryBlastTimer = 60; // 1 second
        }

        function activateDataDash() {
            dataDashActive = true;
            dataDashTimer = 120; // 2 seconds
        }

        // Update game state
        function update() {
            frameCount++;

            // Player movement
            let currentSpeed = dataDashActive ? 10 : 5;
            if (keys['ArrowLeft']) player.x -= currentSpeed;
            if (keys['ArrowRight']) player.x += currentSpeed;
            if (keys['ArrowUp']) player.y -= currentSpeed;
            if (keys['ArrowDown']) player.y += currentSpeed;

            // Keep player within gameplay area (x: 400-1380, y: 0-580)
            player.x = Math.max(400, Math.min(1380, player.x));
            player.y = Math.max(0, Math.min(580, player.y));

            // Spawn code streams (15% probability per column per frame)
            columns.forEach((colX) => {
                if (Math.random() < 0.15) {
                    let char = Math.random() < 0.5 ? '0' : '1';
                    codeCharacters.push({ x: colX, y: 0, char: char });
                }
            });

            // Update code characters
            let codeSpeed = timeControlActive ? 0.25 : 0.5;
            codeCharacters.forEach((code, index) => {
                code.y += codeSpeed;
                if (!matrixImmunityActive && lives > 0) {
                    // Collision with player
                    if (code.y + 15 > player.y && code.y < player.y + player.height &&
                        code.x - 5 < player.x + player.width && code.x + 5 > player.x) {
                        lives--;
                        codeCharacters.splice(index, 1);
                        index--;
                    }
                    // Reaches bottom without hitting player
                    else if (code.y >= 600) {
                        score++;
                        codeCharacters.splice(index, 1);
                        index--;
                    }
                } else if (code.y >= 600) {
                    // Remove characters that reach bottom
                    codeCharacters.splice(index, 1);
                    index--;
                }
            });

            // Update abilities recharge
            abilities.forEach((ability) => {
                if (ability.currentRecharge < ability.rechargeTime) {
                    ability.currentRecharge++;
                }
            });

            // Activate abilities
            if (keys['1'] && abilities[0].currentRecharge >= abilities[0].rechargeTime) {
                activateGrindMode();
                abilities[0].currentRecharge = 0;
            }
            if (keys['2'] && abilities[1].currentRecharge >= abilities[1].rechargeTime) {
                activateMatrixImmunity();
                abilities[1].currentRecharge = 0;
            }
            if (keys['3'] && abilities[2].currentRecharge >= abilities[2].rechargeTime) {
                activateTimeControl();
                abilities[2].currentRecharge = 0;
            }
            if (keys['4'] && abilities[3].currentRecharge >= abilities[3].rechargeTime) {
                activateBinaryBlast();
                abilities[3].currentRecharge = 0;
            }
            if (keys['5'] && abilities[4].currentRecharge >= abilities[4].rechargeTime) {
                activateDataDash();
                abilities[4].currentRecharge = 0;
            }

            // Handle active abilities
            if (matrixImmunityActive) {
                codeCharacters = codeCharacters.filter((code) => {
                    let dx = code.x - (player.x + 10);
                    let dy = code.y - (player.y + 10);
                    return Math.hypot(dx, dy) > 50;
                });
                matrixImmunityTimer--;
                if (matrixImmunityTimer <= 0) matrixImmunityActive = false;
            }
            if (binaryBlastActive) {
                codeCharacters = codeCharacters.filter((code) =>
                    !(code.y < player.y + 10 && Math.abs(code.x - (player.x + 10)) <= 50));
                binaryBlastTimer--;
                if (binaryBlastTimer <= 0) binaryBlastActive = false;
            }
            if (dataDashActive) {
                dataDashTimer--;
                if (dataDashTimer <= 0) dataDashActive = false;
            }
            if (timeControlActive) {
                timeControlTimer--;
                if (timeControlTimer <= 0) timeControlActive = false;
            }

            // Boss logic
            if (score >= 10000 && boss === null && lives > 0) {
                boss = { x: 700, y: 50, width: 100, height: 100, vx: 2, health: 10 };
                powerUp = {
                    x: 410 + Math.random() * 980,
                    y: 10 + Math.random() * 580,
                    width: 20,
                    height: 20
                };
            }
            if (boss !== null) {
                boss.x += boss.vx;
                if (boss.x <= 400 || boss.x >= 1300) boss.vx = -boss.vx;
                if (frameCount % 60 === 0) {
                    let char = Math.random() < 0.5 ? '0' : '1';
                    codeCharacters.push({ x: boss.x + 50, y: boss.y + 100, char: char });
                }
                // Power-up collection
                if (powerUp !== null && player.x < powerUp.x + powerUp.width &&
                    player.x + player.width > powerUp.x &&
                    player.y < powerUp.y + powerUp.height &&
                    player.y + player.height > powerUp.y) {
                    canShoot = true;
                    powerUp = null;
                }
                // Shoot projectiles
                if (canShoot && keys[' '] && frameCount % 30 === 0) {
                    projectiles.push({ x: player.x + 10, y: player.y });
                }
                // Update projectiles
                projectiles.forEach((proj, index) => {
                    proj.y -= 2;
                    if (proj.y < 0) {
                        projectiles.splice(index, 1);
                        index--;
                    } else if (boss !== null && proj.y < boss.y + boss.height &&
                               proj.y > boss.y && proj.x > boss.x &&
                               proj.x < boss.x + boss.width) {
                        boss.health--;
                        projectiles.splice(index, 1);
                        index--;
                        if (boss.health <= 0) {
                            boss = null;
                            canShoot = false;
                            projectiles = [];
                        }
                    }
                });
            }
        }

        // Render game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Gameplay area border
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.strokeRect(400, 0, 1000, 600);

            // Player
            ctx.fillStyle = 'green';
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Code characters
            ctx.font = '12px Courier'; // Fallback for MatrixFont
            ctx.fillStyle = '#0f0';
            codeCharacters.forEach((code) => {
                ctx.fillText(code.char, code.x - 5, code.y);
            });

            // HUD
            ctx.fillStyle = 'green';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.fillText(`Lives: ${lives}`, 10, 60);

            // Ability recharge bars
            let barY = 100;
            abilities.forEach((ability) => {
                let rechargePercent = ability.currentRecharge / ability.rechargeTime;
                ctx.fillStyle = `rgb(0, ${255 * rechargePercent}, 0)`;
                ctx.fillRect(10, barY, 180 * rechargePercent, 10);
                ctx.fillStyle = 'green';
                ctx.font = '16px Arial';
                ctx.fillText(ability.name, 200, barY + 8);
                barY += 20;
            });

            // Controls
            let controlY = barY + 20;
            const controls = [
                "Arrows to move",
                "1-Grind_Mode",
                "2-Matrix_Immunity",
                "3-Time_Control",
                "4-Binary_Blast",
                "5-Data_Dash",
                "Space to shoot during boss"
            ];
            ctx.fillStyle = 'green';
            ctx.font = '16px Arial';
            controls.forEach((text, index) => {
                ctx.fillText(text, 10, controlY + index * 20);
            });

            // Boss
            if (boss !== null) {
                ctx.fillStyle = 'green';
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                ctx.fillStyle = 'black';
                ctx.font = '16px Arial';
                ctx.fillText("Politician", boss.x + 10, boss.y + 20);
                ctx.fillText(`HP: ${boss.health}`, boss.x + 10, boss.y + 40);
            }

            // Power-up
            if (powerUp !== null) {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText("Keyboard", powerUp.x + 2, powerUp.y + 15);
            }

            // Projectiles
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            projectiles.forEach((proj) => {
                ctx.fillText("truth", proj.x - 10, proj.y);
            });

            // Game over
            if (lives <= 0) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("GAME OVER - The Matrix Has You", 900, 300);
            }
            ctx.textAlign = 'left'; // Reset alignment
        }

        // Game loop
        function gameLoop() {
            if (lives > 0 || boss !== null) {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        gameLoop();
    </script>
</body>
</html>
