<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Attack</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            border: 1px solid #0f0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1400" height="600"></canvas> <!-- Maintains wider non-gameplay area -->
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const TOTAL_WIDTH = canvas.width;
        const TOTAL_HEIGHT = canvas.height;
        const GAME_WIDTH = 1000; // Reduced gameplay area width to 1000 pixels
        const GAME_HEIGHT = 600; // Gameplay area height
        const PLAYER_WIDTH = 20;
        const PLAYER_HEIGHT = 20;
        const CODE_WIDTH = 10; // Narrower for single character
        const CODE_HEIGHT = 15; // Adjusted for single character
        const COLUMN_WIDTH = 20; // Narrower columns for denser streams
        const NUM_COLUMNS = Math.floor(GAME_WIDTH / COLUMN_WIDTH);

        // Game State
        let player = {
            x: GAME_WIDTH / 2 - PLAYER_WIDTH / 2,
            y: GAME_HEIGHT - PLAYER_HEIGHT - 10,
            speed: 5,
            lives: 3
        };
        let codeStreams = [];
        let abilities = {
            grindMode: { active: false, recharge: 0, maxRecharge: 300 },
            matrixImmunity: { active: false, recharge: 0, maxRecharge: 400 },
            timeControl: { active: false, recharge: 0, maxRecharge: 500 },
            binaryBlast: { active: false, recharge: 0, maxRecharge: 450 },
            dataDash: { active: false, recharge: 0, maxRecharge: 300 }
        };
        let score = 0;
        let gameOver = false;
        let bossActive = false;
        let boss = null;
        let projectiles = [];
        let powerUp = null;
        let bossTriggerScore = 10000; // Boss triggers at 10,000 points

        // Input Handling
        let keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Code Stream Class (Single Character, Matrix-style with cascading brightness)
        class CodeStream {
            constructor(x, speed, char) {
                this.x = x;
                this.y = -CODE_HEIGHT;
                this.speed = speed;
                this.char = char; // Single random character (0 or 1), pre-assigned for connected paths
                this.brightness = 100; // Start at full brightness
            }
            update() {
                this.y += this.speed * (abilities.timeControl.active ? 0.25 : 0.5); // Slower fall speed
                this.brightness = (this.brightness + Math.random() * 10 - 5 + 20) % 80 + 20; // Vary brightness (20-100, never fades completely)
            }
            draw() {
                ctx.font = '12px MatrixFont'; // Mimic Matrix font style
                ctx.fillStyle = `rgba(0, ${this.brightness}, 0, 1)`; // Green, varying brightness for cascading effect
                ctx.fillText(this.char, this.x + 400, this.y); // Offset for gameplay area (400 for wider non-gameplay area)
            }
        }

        // Boss Class
        class Boss {
            constructor(name, health, attackPattern) {
                this.name = name;
                this.health = health;
                this.x = GAME_WIDTH / 2 - 50;
                this.y = 50;
                this.width = 100;
                this.height = 100;
                this.speed = 2; // Horizontal movement speed
                this.direction = 1; // 1 = right, -1 = left
                this.attackPattern = attackPattern;
                this.attackTimer = 0;
            }
            update() {
                // Horizontal movement
                this.x += this.speed * this.direction;
                if (this.x <= 0 || this.x + this.width >= GAME_WIDTH) {
                    this.direction *= -1;
                }
                this.attackTimer++;
                if (this.attackTimer > 60) {
                    this.attackPattern(this.x + this.width / 2); // Attack from current position
                    this.attackTimer = 0;
                }
            }
            draw() {
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x + 400, this.y, this.width, this.height); // Offset for gameplay area
                ctx.fillStyle = '#000';
                ctx.font = '20px Arial';
                ctx.fillText(this.name, this.x + 410, this.y + 50);
                ctx.fillText(`HP: ${this.health}`, this.x + 410, this.y + 70);
            }
        }

        // Power-Up Class
        class PowerUp {
            constructor() {
                this.x = Math.random() * (GAME_WIDTH - 20);
                this.y = GAME_HEIGHT / 2; // Static position
                this.width = 20;
                this.height = 20;
                this.collected = false;
            }
            draw() {
                ctx.fillStyle = '#ff0';
                ctx.fillRect(this.x + 400, this.y, this.width, this.height); // Offset for gameplay area
                ctx.fillStyle = '#000';
                ctx.font = '10px Arial';
                ctx.fillText('KB', this.x + 404, this.y + 15);
            }
        }

        // Projectile Class
        class Projectile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = -2; // Slower "truth" speed
            }
            update() {
                this.y += this.speed;
            }
            draw() {
                ctx.fillStyle = '#fff';
                ctx.font = '15px Arial';
                ctx.fillText('truth', this.x, this.y);
            }
        }

        // Generate Connected Maze Path for Code Streams
        function generateMazePath() {
            let maze = new Array(NUM_COLUMNS).fill().map(() => []);
            for (let col = 0; col < NUM_COLUMNS; col++) {
                let isGap = Math.random() < 0.6; // Higher probability of gaps for more paths
                let prevGap = col > 0 ? maze[col - 1][maze[col - 1].length - 1] === null : false;
                if (isGap || prevGap) {
                    maze[col].push(null); // Gap (no code)
                } else {
                    maze[col].push(Math.random() < 0.5 ? '0' : '1'); // Code (0 or 1)
                }
            }
            return maze;
        }

        // Spawn Code Streams with Connected Maze Paths
        let mazePath = generateMazePath();
        function spawnCode() {
            if (!bossActive) {
                let newMazePath = generateMazePath(); // Generate new path for each spawn
                for (let i = 0; i < NUM_COLUMNS; i++) {
                    let char = newMazePath[i][0];
                    if (char !== null) { // Only spawn if thereâ€™s code
                        let x = i * COLUMN_WIDTH + Math.random() * (COLUMN_WIDTH - CODE_WIDTH);
                        codeStreams.push(new CodeStream(x, 0.5, char)); // Slower fall speed (0.5)
                    }
                }
                mazePath = newMazePath; // Update maze path for next row connection
            }
        }

        // Spawn Boss
        function spawnBoss() {
            if (!bossActive && score >= bossTriggerScore) {
                boss = new Boss('Politician', 5, (x) => {
                    codeStreams.push(new CodeStream(x, 0.5, Math.random() < 0.5 ? '0' : '1')); // Slower boss attack
                });
                powerUp = new PowerUp();
                bossActive = true;
            }
        }

        // Update Game
        function update() {
            if (gameOver) return;

            // Player Movement
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed * (abilities.dataDash.active ? 2 : 1);
            if (keys['ArrowRight'] && player.x < GAME_WIDTH - PLAYER_WIDTH) player.x += player.speed * (abilities.dataDash.active ? 2 : 1);
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed * (abilities.dataDash.active ? 2 : 1);
            if (keys['ArrowDown'] && player.y < GAME_HEIGHT - PLAYER_HEIGHT) player.y += player.speed * (abilities.dataDash.active ? 2 : 1);

            // Abilities (Adjusted to spawn from player position)
            if (keys['Digit1'] && abilities.grindMode.recharge >= abilities.grindMode.maxRecharge) {
                abilities.grindMode.active = true;
                abilities.grindMode.recharge = 0;
                setTimeout(() => abilities.grindMode.active = false, 2000);
            }
            if (keys['Digit2'] && abilities.matrixImmunity.recharge >= abilities.matrixImmunity.maxRecharge) {
                abilities.matrixImmunity.active = true;
                abilities.matrixImmunity.recharge = 0;
                setTimeout(() => abilities.matrixImmunity.active = false, 3000);
            }
            if (keys['Digit3'] && abilities.timeControl.recharge >= abilities.timeControl.maxRecharge) {
                abilities.timeControl.active = true;
                abilities.timeControl.recharge = 0;
                setTimeout(() => abilities.timeControl.active = false, 4000);
            }
            if (keys['Digit4'] && abilities.binaryBlast.recharge >= abilities.binaryBlast.maxRecharge) {
                abilities.binaryBlast.active = true;
                abilities.binaryBlast.recharge = 0;
                setTimeout(() => abilities.binaryBlast.active = false, 1000);
            }
            if (keys['Digit5'] && abilities.dataDash.recharge >= abilities.dataDash.maxRecharge) {
                abilities.dataDash.active = true;
                abilities.dataDash.recharge = 0;
                setTimeout(() => abilities.dataDash.active = false, 2000);
            }
            if (keys['Space'] && powerUp && powerUp.collected) {
                projectiles.push(new Projectile(player.x + 400 + PLAYER_WIDTH / 2, player.y));
            }

            // Auto-Collect Power-Up
            if (powerUp && !powerUp.collected &&
                player.x < powerUp.x + powerUp.width && player.x + PLAYER_WIDTH > powerUp.x &&
                player.y < powerUp.y + powerUp.height && player.y + PLAYER_HEIGHT > powerUp.y) {
                powerUp.collected = true;
            }

            // Recharge Abilities
            for (let ability in abilities) {
                if (abilities[ability].recharge < abilities[ability].maxRecharge) {
                    abilities[ability].recharge++;
                }
            }

            // Update Code Streams
            spawnCode();
            codeStreams.forEach((code, index) => {
                code.update();
                if (abilities.grindMode.active && Math.abs(code.x + 400 - player.x) < 50) {
                    codeStreams.splice(index, 1);
                } else if (abilities.matrixImmunity.active && Math.abs(code.x + 400 - player.x) < 50 && Math.abs(code.y - player.y) < 50) {
                    codeStreams.splice(index, 1);
                } else if (abilities.binaryBlast.active && Math.abs(code.x + 400 - player.x) < 50 && code.y < player.y) {
                    codeStreams.splice(index, 1);
                } else if (abilities.timeControl.active && Math.abs(code.x + 400 - player.x) < 50) {
                    code.speed *= 0.25; // Further slow down under time control
                } else if (code.y > GAME_HEIGHT) {
                    codeStreams.splice(index, 1);
                    score += 1; // 1 point per dodged code
                } else if (!abilities.timeControl.active && code.x + 400 < player.x + PLAYER_WIDTH && code.x + 400 + CODE_WIDTH > player.x &&
                    code.y < player.y + PLAYER_HEIGHT && code.y + CODE_HEIGHT > player.y) {
                    codeStreams.splice(index, 1);
                    player.lives--;
                    if (player.lives <= 0) gameOver = true;
                }
            });

            // Update Boss
            spawnBoss();
            if (boss) {
                boss.update();
                projectiles.forEach((proj, index) => {
                    proj.update();
                    if (proj.x > boss.x + 400 && proj.x < boss.x + 400 + boss.width && proj.y > boss.y && proj.y < boss.y + boss.height) {
                        boss.health--;
                        projectiles.splice(index, 1);
                        if (boss.health <= 0) {
                            boss = null;
                            bossActive = false;
                            powerUp = null;
                            codeStreams = [];
                        }
                    } else if (proj.y < 0) {
                        projectiles.splice(index, 1);
                    }
                });
            }
        }

        // Draw Game
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, TOTAL_WIDTH, TOTAL_HEIGHT);

            // Draw Gameplay Area Border (Green Square)
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(400, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw Player
            ctx.fillStyle = abilities.timeControl.active ? 'rgba(0, 255, 0, 0.5)' : '#0f0';
            ctx.fillRect(player.x + 400, player.y, PLAYER_WIDTH, PLAYER_HEIGHT); // Offset for gameplay area
            if (abilities.matrixImmunity.active) {
                ctx.beginPath();
                ctx.arc(player.x + 400 + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, 50, 0, Math.PI * 2);
                ctx.strokeStyle = '#0f0';
                ctx.stroke();
            }

            // Draw Code Streams (Confined to gameplay area)
            codeStreams.forEach(code => code.draw());

            // Draw Boss and Power-Up
            if (boss) boss.draw();
            if (powerUp && !powerUp.collected) powerUp.draw();
            projectiles.forEach(proj => proj.draw());

            // Draw HUD (Left Side, Outside Gameplay Area)
            ctx.fillStyle = '#0f0';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.fillText(`Lives: ${player.lives}`, 10, 60);

            // Draw Ability Recharge Bars
            let barY = 100;
            for (let ability in abilities) {
                let rechargePercent = abilities[ability].recharge / abilities[ability].maxRecharge;
                ctx.fillStyle = '#0f0';
                ctx.fillRect(10, barY, 180 * rechargePercent, 10); // Narrow bars to fit within 400 pixels
                ctx.strokeStyle = '#0f0';
                ctx.strokeRect(10, barY, 180, 10);
                ctx.fillText(ability, 200, barY + 10); // Adjusted position for narrower bars
                barY += 20;
            }

            // Draw Controls Horizontally on Separate Rows Below Abilities
            let controlY = barY + 20;
            ctx.fillText('Arrows to move', 10, controlY); controlY += 20;
            ctx.fillText('1-Grind', 10, controlY); controlY += 20;
            ctx.fillText('2-Immunity', 10, controlY); controlY += 20;
            ctx.fillText('3-Time', 10, controlY); controlY += 20;
            ctx.fillText('4-Blast', 10, controlY); controlY += 20;
            ctx.fillText('5-Dash', 10, controlY); controlY += 20;
            ctx.fillText('Space to shoot during boss', 10, controlY);

            if (gameOver) {
                ctx.fillStyle = '#f00';
                ctx.font = '40px Arial';
                ctx.fillText('GAME OVER', 400 + (GAME_WIDTH - 150) / 2, GAME_HEIGHT / 2); // Centered in gameplay area
            }
        }

        // Game Loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
