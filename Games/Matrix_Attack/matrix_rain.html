<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Matrix Digital Rain</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <script>
        // **Setup Canvas**
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const ctx = canvas.getContext('2d');

        // **Set Canvas Size**
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize();

        // **Handle Resize**
        window.addEventListener('resize', () => {
            setCanvasSize();
            initializeStreams();
        });

        // **Character Set**
        const katakana = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
        const cyrillic = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ';
        const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const special = '!@#$%^&*()_+-=[]{}|;:,./<>?';
        const additional = 'ѦѰツシΣΠΩ';
        const binary = '01';
        const characters = katakana + binary;

        function getRandomChar() {
            return characters[Math.floor(Math.random() * characters.length)];
        }

        // **Global Parameters**
        let W, H, f, Z_max, base_v_y, base_v_z, spawn_interval, base_font_size, column_spacing, zoom_factor, last_zoom_time;

        function setParameters() {
            W = canvas.width;
            H = canvas.height;
            f = H * 2;                  // Focal length for perspective
            Z_max = 100;                // Maximum depth
            base_v_y = 50;              // Base Y velocity (units/second)
            base_v_z = 50;              // Base Z velocity towards viewer
            spawn_interval = 0.1;       // Seconds between spawns
            base_font_size = 20;        // Base font size
            column_spacing = 20;        // Spacing between streams
            zoom_factor = 1;            // Starts at 1, increases for zoom
            last_zoom_time = 0;
        }

        // **Stream Class**
        class Stream {
            constructor(x_screen) {
                this.x_screen = x_screen;
                this.characters = [];
                this.last_spawn_time = 0;
                this.v_y = base_v_y * (0.7 + Math.random() * 0.6); // 70% to 130% of base
                this.v_z = base_v_z * (0.7 + Math.random() * 0.6); // Variable speed
            }

            update(dt, current_time) {
                // Update characters
                this.characters.forEach(char => {
                    char.Y += this.v_y * dt;
                    char.Z -= this.v_z * dt;
                    // Random flickering
                    char.opacity = Math.random() < 0.05 ? Math.random() : char.opacity;
                });

                // Remove off-screen characters
                this.characters = this.characters.filter(char => {
                    const y_screen = (f * char.Y) / char.Z + H / 2;
                    return y_screen <= H + 50; // Buffer for motion blur
                });

                // Spawn new character
                if (current_time - this.last_spawn_time > spawn_interval) {
                    const Y_start = - (H / 2) * Z_max / f;
                    this.characters.push({
                        Y: Y_start,
                        Z: Z_max,
                        char: getRandomChar(),
                        opacity: 1,
                        rotation: (Math.random() - 0.5) * 30 // -15 to 15 degrees
                    });
                    this.last_spawn_time = current_time;
                }
            }

            getCharacters() {
                return this.characters.map(char => ({
                    x_screen: this.x_screen,
                    Y: char.Y,
                    Z: char.Z,
                    char: char.char,
                    opacity: char.opacity,
                    rotation: char.rotation
                }));
            }
        }

        // **Initialize Streams**
        let streams = [];
        function initializeStreams() {
            setParameters();
            streams = [];
            const N_streams = Math.ceil(W / column_spacing);
            for (let j = 0; j < N_streams; j++) {
                const x_screen = j * column_spacing;
                streams.push(new Stream(x_screen));
            }
        }
        initializeStreams();

        // **Animation Loop**
        let last_time = performance.now();
        function animate() {
            const current_time = performance.now() / 1000;
            const dt = current_time - last_time;
            last_time = current_time;

            // Update zoom every 5 seconds
            if (current_time - last_zoom_time > 5) {
                zoom_factor += 0.1; // Increase size subtly
                if (zoom_factor > 1.3) zoom_factor = 1; // Reset
                last_zoom_time = current_time;
            }

            // Clear canvas with slight fade for motion blur persistence
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, W, H);

            // Update streams
            streams.forEach(stream => stream.update(dt, current_time));

            // Collect and sort characters by Z (far to near)
            let all_characters = [];
            streams.forEach(stream => {
                all_characters = all_characters.concat(stream.getCharacters());
            });
            all_characters.sort((a, b) => b.Z - a.Z);

            // Define title rectangle
            const rect_x = W * 0.3;
            const rect_y = H * 0.3;
            const rect_width = W * 0.4;
            const rect_height = H * 0.4;

            // Draw characters
            all_characters.forEach(char => {
                const x_screen = char.x_screen;
                const y_screen = (f * char.Y) / char.Z + H / 2;
                if (y_screen < -50 || y_screen > H + 50) return;

                // Skip if inside title rectangle
                if (x_screen >= rect_x && x_screen <= rect_x + rect_width &&
                    y_screen >= rect_y && y_screen <= rect_y + rect_height) {
                    return;
                }

                const scale = (f / char.Z) * zoom_factor;
                const font_size = base_font_size * scale;
                const speed_factor = this.v_z / char.Z; // Closer = faster
                ctx.font = `${font_size}px monospace`;

                // Color variation
                const hue = 120 + (Math.random() - 0.5) * 20; // Slight green variation
                const lightness = 10 + 40 * Math.min(y_screen / H, 1);
                const alpha = char.opacity * 0.8;

                // Motion blur
                const blur_steps = Math.min(Math.floor(speed_factor * 5), 5);
                for (let b = 0; b < blur_steps; b++) {
                    const blur_y = y_screen - b * this.v_y * dt * 10;
                    const blur_alpha = alpha * (1 - b / blur_steps) * 0.3;
                    ctx.fillStyle = `hsla(${hue}, 100%, ${lightness}%, ${blur_alpha})`;
                    ctx.save();
                    ctx.translate(x_screen, blur_y);
                    ctx.rotate(char.rotation * Math.PI / 180);
                    ctx.fillText(char.char, 0, 0);
                    ctx.restore();
                }

                // Main character
                ctx.fillStyle = `hsla(${hue}, 100%, ${lightness}%, ${alpha})`;
                ctx.save();
                ctx.translate(x_screen, y_screen);
                ctx.rotate(char.rotation * Math.PI / 180);
                ctx.fillText(char.char, 0, 0);
                ctx.restore();
            });

            // Draw title rectangle with glow
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'lime';
            ctx.strokeRect(rect_x, rect_y, rect_width, rect_height);
            ctx.shadowBlur = 0;

            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
